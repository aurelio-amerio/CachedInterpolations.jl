var documenterSearchIndex = {"docs":
[{"location":"functions.html#List-of-functions","page":"List of functions","title":"List of functions","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"Modules = [FunctionTabulations]","category":"page"},{"location":"functions.html#FunctionTabulations.compute_SHA-Tuple{Function}","page":"List of functions","title":"FunctionTabulations.compute_SHA","text":"compute_SHA(func)\n\nUtility function to compute the SHA of a function.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.create_tabulation_1D-Union{Tuple{T}, Tuple{Function, Vararg{Any}}} where T<:Union{Real, Unitful.Quantity}","page":"List of functions","title":"FunctionTabulations.create_tabulation_1D","text":"create_tabulation_1D(\n    func::Function[,\n    args...];\n    xmin::T,\n    xmax::T,\n    npoints::Int[,\n    x_scale::Symbol = :linear,\n    f_scale = :linear,\n    jld_base_path = nothing,\n    custom_name = nothing,\n    interpolation_type = :linear,\n    extrapolation_bc = Throw,\n    check_SHA = true,\n    check_SHA_mode = :warn,\n    kwargs...]\n) where {T<:Union{Real,Quantity}}\n\nComputes or loads the tabulation for a given function of the kind f(x).\n\nArguments\n\nfunc::Function: the function which should be tabulated. Must be of the kind f(x)\nxmin::Union{Real,Quantity}: the minimum x for the range which will be covered by the tabulation\nxmax::Union{Real,Quantity}: the maximum x for the range which will be covered by the tabulation\nnpoints::Int: the number of points for which f(x) will be computed\nx_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the x points will be evenly spaced. If :log10 is chosen, the points will be logarithmically spaced. Defaults to :linear\nf_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the f(x) points will not be alterated. If :log10 is chosen, log10 will be applied to the f(x) points before interpolating. Defaults to :linear \njld_base_path: path to the folder where the tabulation should be saved. Defaults to the current folder\ncustom_name: custom name for the tabulation file, to which _data.jld2 will be appended. Defaults to the name of the function to be tabulated\ninterpolation_type: Type of the spline to be used for interpolation. Can either be :linear (1st order spline) or :cubic (3rd order spline)\nextrapolation_bc: behaviour of the tabulation outside of the boundaries defined by [xmin, xmax]. Possible behaviours are handled by Interpolations.jl and include Throw(throws and eror if a value out of bounds is acessed) orLine(extrapolate linearly). Defaults toThrow`\ncheck_SHA::Bool: Whether to check the SHA of the tabulated function. If the SHA of the tabulated function does not match the SHA stored inside the tabulation file, it might be necessary to recompute the tabulation, since it's likely that the definition of the tabulated function has changed.\ncheck_SHA_mode::Symbol: Describes the behaviour of this function if the SHA of the tabulated function does not match the SHA stored inside the tabulation file. Defaults to :warn (print a warning but load the tabulation all the same). Other options include :throw (throw an error to suggest manual deletion of the old tabulation) and :none (don't do anything).\nargs..., kwargs...: additional args and kwargs will be passed to the function which is to be tabulated\n\nExamples\n\njulia>  func_1d(x) = sin(x)\n\njulia>  itp_1d_1 = create_tabulation_1D(\n            func_1d,\n            xmin = 0.0,\n            xmax = 3.0,\n            npoints = 100,\n            x_scale = :linear,\n            f_scale = :linear\n        )\n\njulia>  isapprox(itp_1d_1(2.0), func_1d(2.0), rtol = 1e-3)\ntrue\n\nMeasurement units are supported too:\n\njulia>  using Unitful\n\njulia>  func_1d(x) = x^2\n\njulia>  itp_1d_1 = create_tabulation_1D(\n            func_1d,\n            xmin = 0.0u\"m\",\n            xmax = 3.0u\"m\",\n            npoints = 100,\n            x_scale = :linear,\n            f_scale = :linear\n        )\n\njulia>  isapprox(itp_1d_1(2.0u\"m\"), func_1d(2.0u\"m\"), rtol = 1e-3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.create_tabulation_1D-Union{Tuple{T}, Tuple{Function, Vector{T}, Vararg{Any}}} where T<:Union{Real, Unitful.Quantity}","page":"List of functions","title":"FunctionTabulations.create_tabulation_1D","text":"create_tabulation_1D(\n    func::Function,\n    x::Vector{T},\n    args...;\n    jld_base_path = nothing,\n    custom_name = nothing,\n    x_scale::Symbol = :linear,\n    f_scale = :linear,\n    interpolation_type = :linear,\n    extrapolation_bc = Throw,\n    check_SHA = true,\n    check_SHA_mode = :warn,\n    kwargs...\n    ) where {T<:Union{Real,Quantity}}\n\nProvides an interface for create_tabulation_1D where the tabulation points are defined by the Vector x. Only LinearInterpolation is supported.`\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.create_tabulation_2D-Union{Tuple{V}, Tuple{T}, Tuple{Function, Vararg{Any}}} where {T<:Union{Real, Unitful.Quantity}, V<:Union{Real, Unitful.Quantity}}","page":"List of functions","title":"FunctionTabulations.create_tabulation_2D","text":"create_tabulation_2D(\n    func::Function[,\n    args...];\n    xmin::T,\n    xmax::T,\n    ymin::V,\n    ymax::V,\n    npoints_x::Int,\n    npoints_y::Int[,\n    x_scale::Symbol = :linear,\n    y_scale::Symbol = :linear,\n    f_scale = :linear,\n    jld_base_path = nothing,\n    custom_name = nothing,\n    interpolation_type = :linear,\n    extrapolation_bc = Throw,\n    check_SHA = true,\n    check_SHA_mode = :warn,\n    kwargs...]\n) where {T<:Union{Real,Quantity},V<:Union{Real,Quantity}}\n\nComputes or loads the tabulation for a given function of the kind f(x, y).\n\nArguments\n\nfunc::Function: the function which should be tabulated. Must be of the kind f(x, y)\nxmin::Union{Real,Quantity}: the minimum x for the range which will be covered by the tabulation\nxmax::Union{Real,Quantity}: the maximum x for the range which will be covered by the tabulation\nymin::Union{Real,Quantity}: the minimum y for the range which will be covered by the tabulation\nymax::Union{Real,Quantity}: the maximum y for the range which will be covered by the tabulation\nnpoints_x::Int: the number of points along the x axis for which f(x,y) will be computed\nnpoints_y::Int: the number of points along the y axis for which f(x,y) will be computed\nx_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the x points will be evenly spaced. If :log10 is chosen, the points will be logarithmically spaced. Defaults to :linear\ny_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the y points will be evenly spaced. If :log10 is chosen, the points will be logarithmically spaced. Defaults to :linear\nf_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the f(x) points will not be alterated. If :log10 is chosen, log10 will be applied to the f(x) points before interpolating. Defaults to :linear \njld_base_path: path to the folder where the tabulation should be saved. Defaults to the current folder\ncustom_name: custom name for the tabulation file, to which _data.jld2 will be appended. Defaults to the name of the function to be tabulated\ninterpolation_type: Type of the spline to be used for interpolation. Can either be :linear (1st order spline) or :cubic (3rd order spline)\nextrapolation_bc: behaviour of the tabulation outside of the boundaries defined by [xmin, xmax]. Possible behaviours are handled by Interpolations.jl and include Throw(throws and eror if a value out of bounds is acessed) orLine(extrapolate linearly). Defaults toThrow`\ncheck_SHA::Bool: Whether to check the SHA of the tabulated function. If the SHA of the tabulated function does not match the SHA stored inside the tabulation file, it might be necessary to recompute the tabulation, since it's likely that the definition of the tabulated function has changed.\ncheck_SHA_mode::Symbol: Describes the behaviour of this function if the SHA of the tabulated function does not match the SHA stored inside the tabulation file. Defaults to :warn (print a warning but load the tabulation all the same). Other options include :throw (throw an error to suggest manual deletion of the old tabulation) and :none (don't do anything).\nargs..., kwargs...: additional args and kwargs will be passed to the function which is to be tabulated\n\nExamples\n\njulia>  func_2d(x, y) = sin(x) * sin(y)\n\njulia>  itp_2d_1 = create_tabulation_2D(\n            func_2d,\n            xmin = 0.0,\n            xmax = 1.0,\n            ymin = 0.0,\n            ymax = 2.0,\n            npoints_x = 100,\n            npoints_y = 100,\n        )\n\njulia>  isapprox(itp_2d_1(1.0, 1.3), func_2d(1.0, 1.3), rtol = 1e-3)\ntrue\n\nMeasurement units are supported too:\n\njulia>  using Unitful\n\njulia>  func_2d(x, y) = x^2 + y\n\njulia>  itp_2d_1 = create_tabulation_2D(\n            func_2d,\n            xmin = 0.0u\"m\",\n            xmax = 1.0u\"m\",\n            ymin = 0.0u\"m^2\",\n            ymax = 2.0u\"m^2\",\n            npoints_x = 100,\n            npoints_y = 100,\n        )\n\njulia>  isapprox(itp_2d_1(1.0u\"m\", 1.3u\"m^2\"), func_2d(1.0u\"m\", 1.3u\"m^2\"), rtol = 1e-3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.create_tabulation_2D-Union{Tuple{V}, Tuple{T}, Tuple{Function, Vector{T}, Vector{V}, Vararg{Any}}} where {T<:Union{Real, Unitful.Quantity}, V<:Union{Real, Unitful.Quantity}}","page":"List of functions","title":"FunctionTabulations.create_tabulation_2D","text":"function create_tabulation_2D(\n    func::Function,\n    x::Vector{T},\n    y::Vector{V},\n    args...;\n    jld_base_path = nothing,\n    custom_name = nothing,\n    x_scale::Symbol = :linear,\n    y_scale::Symbol = :linear,\n    f_scale = :linear,\n    interpolation_type = :linear,\n    extrapolation_bc = Throw,\n    check_SHA = true,\n    check_SHA_mode = :warn,\n    kwargs...\n) where {T<:Union{Real,Quantity},V<:Union{Real,Quantity}}\n\nProvides an interface for create_tabulation_2D where the tabulation points are defined by the Vectors x and y. Only LinearInterpolation is supported.`\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.create_tabulation_3D-Union{Tuple{W}, Tuple{V}, Tuple{T}, Tuple{Function, Vararg{Any}}} where {T<:Union{Real, Unitful.Quantity}, V<:Union{Real, Unitful.Quantity}, W<:Union{Real, Unitful.Quantity}}","page":"List of functions","title":"FunctionTabulations.create_tabulation_3D","text":"create_tabulation_3D(\n    func::Function[,\n    args...];\n    xmin::T,\n    xmax::T,\n    ymin::V,\n    ymax::V,\n    zmin::W,\n    zmax::W,\n    npoints_x::Int,\n    npoints_y::Int,\n    npoints_z::Int[,\n    x_scale::Symbol = :linear,\n    y_scale::Symbol = :linear,\n    z_scale::Symbol = :linear,\n    f_scale = :linear,\n    jld_base_path = nothing,\n    custom_name = nothing,\n    interpolation_type = :linear,\n    extrapolation_bc = Throw,\n    check_SHA = true,\n    check_SHA_mode = :warn,\n    kwargs...]\n) where {T<:Union{Real,Quantity},V<:Union{Real,Quantity},W<:Union{Real,Quantity}}\n\nComputes or loads the tabulation for a given function of the kind f(x, y, z).\n\nArguments\n\nfunc::Function: the function which should be tabulated. Must be of the kind f(x, y)\nxmin::Union{Real,Quantity}: the minimum x for the range which will be covered by the tabulation\nxmax::Union{Real,Quantity}: the maximum x for the range which will be covered by the tabulation\nymin::Union{Real,Quantity}: the minimum y for the range which will be covered by the tabulation\nymax::Union{Real,Quantity}: the maximum y for the range which will be covered by the tabulation\nzmin::Union{Real,Quantity}: the minimum z for the range which will be covered by the tabulation\nzmax::Union{Real,Quantity}: the maximum z for the range which will be covered by the tabulation\nnpoints_x::Int: the number of points along the x axis for which f(x,y,z) will be computed\nnpoints_y::Int: the number of points along the y axis for which f(x,y,z) will be computed\nnpoints_z::Int: the number of points along the z axis for which f(x,y,z) will be computed\nx_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the x points will be evenly spaced. If :log10 is chosen, the points will be logarithmically spaced. Defaults to :linear\ny_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the y points will be evenly spaced. If :log10 is chosen, the points will be logarithmically spaced. Defaults to :linear\nz_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the z points will be evenly spaced. If :log10 is chosen, the points will be logarithmically spaced. Defaults to :linear\nf_scale::Symbol: the scale which will be used for tabulation. If :linear is choosen, the f(x) points will not be alterated. If :log10 is chosen, log10 will be applied to the f(x) points before interpolating. Defaults to :linear \njld_base_path: path to the folder where the tabulation should be saved. Defaults to the current folder\ncustom_name: custom name for the tabulation file, to which _data.jld2 will be appended. Defaults to the name of the function to be tabulated\ninterpolation_type: Type of the spline to be used for interpolation. Can either be :linear (1st order spline) or :cubic (3rd order spline)\nextrapolation_bc: behaviour of the tabulation outside of the boundaries defined by [xmin, xmax]. Possible behaviours are handled by Interpolations.jl and include Throw(throws and eror if a value out of bounds is acessed) orLine(extrapolate linearly). Defaults toThrow`\ncheck_SHA::Bool: Whether to check the SHA of the tabulated function. If the SHA of the tabulated function does not match the SHA stored inside the tabulation file, it might be necessary to recompute the tabulation, since it's likely that the definition of the tabulated function has changed.\ncheck_SHA_mode::Symbol: Describes the behaviour of this function if the SHA of the tabulated function does not match the SHA stored inside the tabulation file. Defaults to :warn (print a warning but load the tabulation all the same). Other options include :throw (throw an error to suggest manual deletion of the old tabulation) and :none (don't do anything).\nargs..., kwargs...: additional args and kwargs will be passed to the function which is to be tabulated\n\nExamples\n\njulia>  func_3d(x, y, z) = x * y + z\n\njulia>  itp_3d_1 = create_tabulation_3D(\n            func_3d,\n            xmin = 0.0,\n            xmax = 1.0,\n            ymin = 0.0,\n            ymax = 2.0,\n            zmin = 0.0,\n            zmax = 3.0,\n            npoints_x = 100,\n            npoints_y = 100,\n            npoints_z = 100,\n        )\n\njulia>  isapprox(itp_3d_1(1.0, 1.3, 2.5), func_3d(1.0, 1.3, 2.5), rtol = 1e-3)\ntrue\n\nMeasurement units are supported too:\n\njulia>  using Unitful\n\njulia>  func_3d(x, y, z) = x * y + z\n\njulia>  itp_3d_1 = create_tabulation_3D(\n            func_3d,\n            xmin = 0.0u\"m\",\n            xmax = 1.0u\"m\",\n            ymin = 0.0\"s^-1\",\n            ymax = 2.0\"s^-1\",\n            zmin = 0.0u\"m/s\",\n            zmax = 3.0u\"m/s\",\n            npoints_x = 100,\n            npoints_y = 100,\n            npoints_z = 100,\n        )\n\njulia>  isapprox(itp_3d_1(1.0u\"m\", 1.3u\"s^-1\", 2.5u\"m/s\"), func_3d(1.0u\"m\", 1.3u\"s^-1\", 2.5u\"m/s\"), rtol = 1e-3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.create_tabulation_3D-Union{Tuple{W}, Tuple{V}, Tuple{T}, Tuple{Function, Vector{T}, Vector{V}, Vector{W}, Vararg{Any}}} where {T<:Union{Real, Unitful.Quantity}, V<:Union{Real, Unitful.Quantity}, W<:Union{Real, Unitful.Quantity}}","page":"List of functions","title":"FunctionTabulations.create_tabulation_3D","text":"function create_tabulation_3D(\n    func::Function,\n    x::Vector{T},\n    y::Vector{V},\n    z::Vector{W},\n    args...;\n    jld_base_path = nothing,\n    custom_name = nothing,\n    x_scale::Symbol = :linear,\n    y_scale::Symbol = :linear,\n    z_scale::Symbol = :linear,\n    f_scale = :linear,\n    interpolation_type = :linear,\n    extrapolation_bc = Throw,\n    check_SHA = true,\n    check_SHA_mode = :warn,\n    kwargs...\n) where {T<:Union{Real,Quantity},V<:Union{Real,Quantity},W<:Union{Real,Quantity}}\n\nProvides an interface for create_tabulation_3D where the tabulation points are defined by the Vectors x, y and z. Only LinearInterpolation is supported.`\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.scaler-Tuple{Real, Symbol}","page":"List of functions","title":"FunctionTabulations.scaler","text":"scaler(x::Real, scale::Symbol)\n\nUtility function to scale a variable, accepts :linear and :log10 scale\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.test_sha-Tuple{Function, String}","page":"List of functions","title":"FunctionTabulations.test_sha","text":"test_sha(func, sha[; mode = :warn])\n\nCompares the SHA of the func funtion with the provided SHA.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.un_scaler-Tuple{Real, Symbol}","page":"List of functions","title":"FunctionTabulations.un_scaler","text":"un_scaler(x::Real, scale::Symbol)\n\nUtility function to un_scale a variable, accepts :linear and :log10 scale\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.wrap_function_1D_add_units-Tuple{Function, Any, Any, Vararg{Any}}","page":"List of functions","title":"FunctionTabulations.wrap_function_1D_add_units","text":"wrap_function_1D_add_units(func, x_units, f_units[, args...; kwargs...])\n\nAdd units back to a 1D function.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.wrap_function_1D_remove_units-Tuple{Function, Any, Any, Vararg{Any}}","page":"List of functions","title":"FunctionTabulations.wrap_function_1D_remove_units","text":"wrap_function_1D_remove_units(func, x_units, f_units[, args...; kwargs...])\n\nRemove units from a 1D function.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.wrap_function_2D_add_units-Tuple{Function, Any, Any, Any, Vararg{Any}}","page":"List of functions","title":"FunctionTabulations.wrap_function_2D_add_units","text":"wrap_function_2D_add_units(func, x_units, y_units, f_units[, args...; kwargs...])\n\nAdd units back to a 2D function.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.wrap_function_2D_remove_units-Tuple{Function, Any, Any, Any, Vararg{Any}}","page":"List of functions","title":"FunctionTabulations.wrap_function_2D_remove_units","text":"wrap_function_2D_remove_units(func, x_units, y_units, f_units[, args...; kwargs...])\n\nRemove units from a 2D function.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.wrap_function_3D_add_units-Tuple{Function, Any, Any, Any, Any, Vararg{Any}}","page":"List of functions","title":"FunctionTabulations.wrap_function_3D_add_units","text":"wrap_function_3D_add_units(func, x_units, y_units, z_units, f_units[, args...; kwargs...])\n\nAdd units back to a 3D function.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#FunctionTabulations.wrap_function_3D_remove_units-Tuple{Function, Any, Any, Any, Any, Vararg{Any}}","page":"List of functions","title":"FunctionTabulations.wrap_function_3D_remove_units","text":"wrap_function_3D_remove_units(func, x_units, y_units, z_units, f_units[, args...; kwargs...])\n\nRemove units from a 3D function.\n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = FunctionTabulations","category":"page"},{"location":"index.html#FunctionTabulations","page":"Home","title":"FunctionTabulations","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"FunctionTabulations.jl is a wrapper around Interpolations.jl to compute interpolation tables (FunctionTabulations) for functions of up to three variables with support for Unitful. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This package stems from the common need in physics research projects to tabulate slow functions. With this package, it becomes possible to easily compute the values of a function and tabulate its values for up to three variables. ","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"FunctionTabulations\")","category":"page"},{"location":"index.html#Usage:-1D-FunctionTabulations","page":"Home","title":"Usage: 1D FunctionTabulations","text":"","category":"section"},{"location":"index.html#Simple-usage","page":"Home","title":"Simple usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To compute and load the tabulation of a function with one variable, it is necessary to use create_tabulation_1D:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using FunctionTabulations\r\n\r\nfunc_1D(x) = sin(x)\r\n\r\nsin_tabulation = create_tabulation_1D(func_1D, xmin = 0.0, xmax = 3.0, npoints = 100) # produces a file called `func_1D_data.jld2`\r\n\r\nisapprox(sin(3.0), sin_tabulation(3.0), rtol=1e-3)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It is always necessary to specify the function to be tabulated, the interval and the number of points of the tabulation grid.  The routine will compute npoints values of the function in the range xmin:xmax, save the table in a .jld2 file, and return the interpolating function of the tabulated data. If a proper .jld2 file already exists for that function, and it was computed in the same x range with the same number of points npoints, it will automatically be loaded on subsequent calls of compute_tabulation_1D.","category":"page"},{"location":"index.html#Logarithmic-scale","page":"Home","title":"Logarithmic scale","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Sometimes, it is more advantageous to tabulate a function using a logarithmic scale. For example, a function y=f(x) might display a more linear trend when the x or f(x) axis is expressed in logarithmic (log10) scale. In this case, it is possible to ask the routine to tabulate or interpolate that axis in logarithmic scale. For example, given the function f(x)=10^x, it is more advantageous to consider the f(x) axis in logarithmic scale for the interpolation:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"func_1D(x) = 10^x\r\n\r\nfunc_1D_tabulation = create_tabulation_1D(func_1D, xmin = 0.0, xmax = 3.0, npoints = 100, f_scale=:log10)\r\n\r\nisapprox(func_1D(3.0), func_1D_tabulation(3.0), rtol=1e-3)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"On the other hand, a function which needs to be interpolated in a wide range of x and does not vary harshly with x may benefit from the option x_scale=:log10.","category":"page"},{"location":"index.html#Unitful-support","page":"Home","title":"Unitful support","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"FunctionTabulations.jl supports Unitful.jl. It is possible to tabulate functions which have variables of the Quantity type, and/or return quantities. This means that units of measurement are fully supported.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Unitful\r\n\r\nfunc_1d(x) = x^2\r\n\r\nitp_1d_1 = create_tabulation_1D(\r\n    func_1d,\r\n    custom_name = \"1d_1\",\r\n    xmin = 0.0u\"m\",\r\n    xmax = 3.0u\"m\",\r\n    npoints = 100,\r\n    x_scale = :linear,\r\n    f_scale = :linear\r\n)\r\n\r\nisapprox(itp_1d_1(2.0u\"m\"), func_1d(2.0u\"m\"), rtol = 1e-3)\r\n    ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In the case of a tabulation with units of measurement, the unit of the result of the tabulated function is the one returned by f(xmin). Nontheless, it supports automatic unit conversion for the input variables:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"func_1d(x) = x^2\r\n\r\nitp_1d_1 = create_tabulation_1D(\r\n    func_1d,\r\n    custom_name = \"1d_1\",\r\n    xmin = 0.0u\"m\",\r\n    xmax = 3.0u\"m\",\r\n    npoints = 100,\r\n    x_scale = :linear,\r\n    f_scale = :linear\r\n)\r\n\r\nisapprox(itp_1d_1(2.0u\"m\"), itp_1d_1(200.0u\"cm\"), rtol = 1e-3)\r\n    ","category":"page"},{"location":"index.html#Save-location","page":"Home","title":"Save location","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"It is possible to specify the folder where to save/load the interpolation using the option jld_base_path. Furthermore it is possible to specify the name of the file in which the interpolation will be stored using the option custom_name. Please note that the suffix _data.jld2 will always be appended to the filename when the tabulation is stored. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"func_1d(x) = sin(x)\r\n\r\nitp_1d_2 = create_tabulation_1D(\r\n    func_1d,\r\n    jld_base_path = \"interpolations\",\r\n    custom_name = \"1d_2\",\r\n    xmin = 0.0,\r\n    xmax = 3.0,\r\n    npoints = 100,\r\n) \r\n# will generate a file called \"1d_2_data.jld2\" in the folder \"interpolations\". \r\n# If the folder doesn't exist, the routine will create it.","category":"page"},{"location":"index.html#Interpolation-options","page":"Home","title":"Interpolation options","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"It is possible to customize the behaviour of the interpolation of the tabulated grid using interpolation_type and extrapolation_bc. The default interpolation method is a linear interpolation (:linear), but it is also possible to use a cubic spline (:cubic). Furthermore, it is possible to specify the behaviour outside of the tabulation domain (xmin, xmax) using extrapolation_bc. The default behaviour is to throw an exception, but it is also possible for to extrapolate linearly:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Interpolations: Line\r\n\r\nfunc_1d(x) = sin(x)\r\n\r\nitp_1d_1 = create_tabulation_1D(\r\n    func_1d,\r\n    xmin = 0.0,\r\n    xmax = 3.0,\r\n    npoints = 100,\r\n    x_scale = :linear,\r\n    f_scale = :linear,\r\n    interpolation_type = :linear,\r\n    extrapolation_bc = Line,\r\n)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For more information about the extrapolation conditions, see the Interpolations.jl documentation and pass the extrapolation function as the extrapolation_bc argument.","category":"page"},{"location":"index.html#Extra-args-and-kwargs","page":"Home","title":"Extra args and kwargs","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In case it is necessary to pass further fixed positional arguments or keyword arguments to the tabulated function, create_tabulation_1D will pass the extra args and kwargs to the function to be tabulated:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"func_1d(x, a; b) = x^2 + a*b\r\n\r\nitp_1d_1 = create_tabulation_1D(\r\n    func_1d,\r\n    2, # the `a` positional argument \r\n    xmin = 0.0,\r\n    xmax = 3.0,\r\n    npoints = 100,\r\n    b=1, # the `b` positional argument\r\n)\r\n\r\nisapprox(itp_1d_1(2.0), func_1d(2.0, 2; b=1), rtol = 1e-3)","category":"page"},{"location":"index.html#Usage:-2D-FunctionTabulations-and-3D-FunctionTabulations","page":"Home","title":"Usage: 2D FunctionTabulations & 3D FunctionTabulations","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"2D FunctionTabulations and 3D FunctionTabulations have a similar syntax, with extra parameters for the y and z variables:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"func_2d(x, y) = sin(x) * sin(y)\r\n\r\nitp_2d_1 = create_tabulation_2D(\r\n    func_2d,\r\n    xmin = 0.0,\r\n    xmax = 1.0,\r\n    ymin = 0.0,\r\n    ymax = 2.0,\r\n    npoints_x = 100,\r\n    npoints_y = 200,\r\n    x_scale = :linear,\r\n    y_scale = :linear,\r\n    f_scale = :linear\r\n)\r\nisapprox(itp_2d_1(1.0, 1.3), func_2d(1.0, 1.3), rtol = 1e-3)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"func_3d(x, y, z) = x * y + z\r\n\r\nitp_3d_1 = create_tabulation_3D(\r\n    func_3d,\r\n    xmin = 0.0,\r\n    xmax = 1.0,\r\n    ymin = 0.0,\r\n    ymax = 2.0,\r\n    zmin = 0.0,\r\n    zmax = 3.0,\r\n    npoints_x = 100,\r\n    npoints_y = 200,\r\n    npoints_z = 200,\r\n    x_scale = :linear,\r\n    y_scale = :linear,\r\n    z_scale = :linear,\r\n    f_scale = :linear\r\n)\r\n\r\nisapprox(itp_3d_1(1.0, 1.3, 2.5), func_3d(1.0, 1.3, 2.5), rtol = 1e-3)","category":"page"}]
}
