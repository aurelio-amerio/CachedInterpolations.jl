module CachedInterpolations
using Interpolations
using JLD
using ProgressMeter
using Unitful
using Unitful: NoUnits
using Base.Threads

export Interp_1D, create_interpolation_1D, get_interpolation

get_unit_annotation(x::Union{Quantity, Unitful.FreeUnits}) = Quantity{T, dimension(x), W} where {T<:Real, W <: Unitful.FreeUnits}

abstract type Interpolation end

struct Interp_1D{T <: Unitful.FreeUnits, W <: Unitful.FreeUnits} <: Interpolation
    itp::Function
    x_units::T
    f_units::W
end

function Interp_1D(itp::Function; x_units::T = NoUnits, f_units::W = NoUnits) where {T <: Unitful.FreeUnits, W <: Unitful.FreeUnits}
    Interp_1D{T, W}(itp, x_units, f_units)
end

# function get_interpolation(data::Interpolation)
#     error("TODO: implement for $(typeof(data))")
# end

function create_interpolation_1D(
    func::Function,
    args...;
    jld_base_path = nothing,
    custom_name = nothing,
    xmin::Real,
    xmax::Real,
    npoints::Int,
    scale_x=:linear,
    scale_f=:linear,
    extrapolation_bc = Throw,
    kwargs...,
)

    func_name = nameof(func)

    arg(x) = func(x, args...; kwargs...)

    f_unit = unit(arg(xmin))

    if isnothing(jld_base_path)  
        base_path = pwd()
    else
        base_path = jld_base_path
    end

    if !(ispath(base_path))
        mkdir(base_path)
    end

    if isnothing(custom_name)
        filename = "$(func_name)_data.jld"
    else
        filename = "$(custom_name)_data.jld"
    end
    
    filepath = "$(base_path)/$(filename)"

    function load_file()
        if isfile(filepath)
            data = load(filepath)
            if data["xmin"] == xmin && data["xmax"] == xmax 
                return true
            else
                return false
            end
        else
            return false
        end
    end

    if load_file()
        data = load(filepath)
        @info "$(filename) loaded!"
        x = data["x"]

        data_matrix = data["func"]
        
    else
        if scale_x == :linear
            x = range(xmin, xmax, length = npoints)
        elseif scale_x == :log
            x = 10 .^ range(log10(xmin), log10(xmax), length = npoints)
        else
            error("X scale $scale_x not supported")
        end

        if isnothing(custom_name)
            @info "Computing $(func_name) Interpolation"
        else
            @info "Computing $(custom_name) Interpolation"
        end
        
        p = Progress(Int(npoints))
        update!(p, 0)

        data_matrix = zeros(npoints)

        @threads for i = 1:npoints

            data_matrix[i] = arg(x[i])

            next!(p)
        end

        data_dict = Dict{
            String,
            Union{
                String,
                Real,
                Array{Float64},
            },
        }()
        data_dict["x"] = collect(x)
        data_dict["func"] = convert(Array{Float64}, data_matrix)

        data_dict["xmin"] = xmin
        data_dict["xmax"] = xmax

        save(filepath, data_dict)
        @info "$(filename) created and exported!"
    end

    data_matrix[data_matrix.<1e-299] .= 1e-300

    function scaler(x, scale)
        if scale == :linear
            return x
        elseif scale == :log
            return log10(x)
        else
            error("Scale $scale not supported")
        end
    end

    function un_scaler(x, scale)
        if scale == :linear
            return x
        elseif scale == :log
            return 10 .^ x
        else
            error("Scale $scale not supported")
        end
    end


    knots = (scaler.(x, scale_x), )
    f_matrix = scaler.(data_matrix, scale_f)

    itp = LinearInterpolation(knots, f_matrix , extrapolation_bc = extrapolation_bc())

    function func_interp(x::Real)
        return un_scaler(itp(scaler(x, scale_x)), scale_f)*f_unit
    end

    return func_interp::Function
end


macro get_interpolation(data)
    x_type = get_unit_annotation(data.x_units)
    quote
        function interpolation(x::T) where {T <: x_type}
            x_v = ustrip(data.x_units, x)
            return data.itp(x_v) :: typeof(1.0*f_units)
        end
    end
end

end
